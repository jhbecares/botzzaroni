#include "s3c44b0x.h"
#include "s3cev40.h"
#include "iic.h"

extern uint32 mclk;			   // Frecuencia actual del reloj (Hz)

extern void DelayMs(int ms_time);

void iic_init( void )
{
	// Enable IIC(bit 13) & GPIO(bit 10) & BDMA(bit 7) blocks (si no se activa BDMA, el controlador IIC no es accesible)
	CLKCON |= (1 << 13) | (1 << 10) | (1 << 7);
	
	// PF[1] = IICSDA, PF[0] = IICSCL
	PCONF = (PCONF &~(0xF)) | (2 << 2) | (2 << 0);

	// Pull-up enable
    PUPF &= ~(0x3);

	//Configurar la dirección del slave
    IICADD = S3C44B0X_SLAVE_ADDRESS << 1;
    IICCON = (1 << 7 ) | (1 << 5);

    //Generación ACK habilitada, interrupciones habilitadas
    IICCON = IICCON | ((mclk / 4000000 - 1) & 0xf); 	//Valor de preescalado, PREESCALER = mclk/16/250000 -1

    // Activa Tx/Rx
    IICSTAT = (1 << 4);
}

void iic_putByte_start( uint8 byte )
{
	// Escribe el dato
	// Máster Tx, start condition, Tx/Rx habilitada
	// Comienza la transmisión (borrando pending bit del IICCON)
    // Espera la recepción de ACK  
	IICDS = byte;  // opaddr_w (10100000)
	IICSTAT = 0xF0; // START_C

	// enviamos el ACK
	IICCON &= ~(1<<4);
	while (!(IICCON &(1<<4)));
}

void iic_putByte( uint8 byte )
{
    // Escribe el dato
	// Comienza la transmisión del dato (borrando pending bit del IICCON)
    // Espera la recepción de ACK  
	IICDS = byte;
	IICCON &= ~(1<<4);
	while (!(IICCON &(1<<4)));
};

void iic_putByte_stop( uint8 byte )
{
    // Escribe el dato
	// Comienza la trasmisión del dato (borrando pending bit del IICCON)
    // Espera la recepción de ACK  
	IICDS = byte;
	IICCON &= ~(1<<4);
	while (!(IICCON &(1<<4)));
    
    // Máster Tx, stop condition, Tx/Rx habilitada
    // Comienza la trasmisión de STOP (borrando pending bit del IICCON)
    // Espera a que la stop condition tenga efecto (5 ms para la at24c04)
	IICSTAT = 0xD0;
	IICCON &= ~(1<<4);
	DelayMs(5);
}

void iic_getByte_start( uint8 byte )
{
	// Escribe el dato
    // Máster Rx, start condition, Tx/Rx habilitada
    // Comienza la transmisión (borrando pending bit del IICCON)
    // Espera la rececpión de ACK
	IICDS = byte;
	IICSTAT = 0xB0;
	IICCON &= ~(1 << 4);
	while (!(IICCON &(1 << 4)));
}

uint8 iic_getByte( void )
{
    // Reanuda la recepción (borrando pending bit del IICCON).
	IICCON &= ~(1 << 4);//TODO:  HACER ALGO O QUE ?????
	while(!(IICCON &(1<<4)));
	// Espera la recepción del dato
    return IICDS;// Lee el dato
}

uint8 iic_getByte_stop( int8 ack )
{
	uint8 byte;

    IICCON = (IICCON & ~(1 << 7)) | (ack << 7); // Habilita/deshabilita la generación de ACK

	IICCON &= ~(1 << 4);//TODO:  HACER ALGO O QUE ?????
    while(!(IICCON &(1<<4)));
    // Reanuda la recepción (borrando pending bit del IICCON)
	// Espera la recepción del dato
    byte = IICDS;	// Lee el dato

    IICSTAT = 0x90;
    IICCON &= ~(1 << 4);
   	// Máster Rx, stop condition, Tx/Rx habilitada
   	// Comienza la trasmisión de STOP (borrando pending bit del IICCON)
   	// Espera a que la stop condition tenga efecto (5 ms para la at24c04)
    DelayMs(5);
	IICCON |= (1<<7); // Habilita la generación de ACK
   	return byte;
}
