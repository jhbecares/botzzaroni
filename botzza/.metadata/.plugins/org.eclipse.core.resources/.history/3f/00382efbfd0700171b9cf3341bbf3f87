/*--- Ficheros de cabecera ---*/
#include "44b.h"
#include "44blib.h"
#include "def.h"
#include "mainstates.h"
/*--- Definición de macros ---*/
#define KEY_VALUE_MASK 0xF
/*--- Variables globales ---*/
volatile UCHAR *keyboard_base = (UCHAR *)0x06000000;
int key;
/*--- Funciones externas ---*/
void D8Led_symbol(int value);
/*--- Declaracion de funciones ---*/
void keyboard_init();
void KeyboardInt(void) __attribute__ ((interrupt ("IRQ")));

extern State get_current_state();

int first_num = -1;
int second_num = -1;
int op = -1;

/*--- Codigo de las funciones ---*/
void keyboard_init()
{
  /* Configurar el puerto G (si no lo estuviese ya) */	
  // Establece la funcion de los pines (EINT0-7)
  rPCONG = 0xFFFF; // si los pines no empiezan en 0, cambiar a 0xC3FF

  // Habilita el "pull up" del puerto
  rPUPG = 0x00;

  // Configura las lineas de int. como de flanco de bajada mediante EXTINT
  rEXTINT = rEXTINT | 0x22222222; // be, ec

  /* Establece la rutina de servicio para EINT1 */
  pISR_EINT1 = (unsigned)KeyboardInt; 

  //
  /* Configurar controlador de interrupciones */
  // Borra INTPND escribiendo 1s en I_ISPC
  rI_ISPC = 0xFFFF; //BIT_EINT4567;
  // Configura las lineas como de tipo IRQ mediante INTMOD -> a 0
  // para que active IRQ o a 1 para que active FIQ
  rINTMOD = 0x0;
  // Habilita int. vectorizadas y la linea IRQ (FIQ no) mediante INTCON
  rINTCON = 0x1; // and con 1001 para mantener el bit 3 y
  // habilitar el 1 y el 2

  /* Habilitar linea EINT1 */
  rINTMSK = rINTMSK & ~(BIT_GLOBAL | BIT_EINT1);
  //
  /* Por precaucion, se vuelven a borrar los bits de INTPND correspondientes*/
  rEXTINTPND = 0xF; // TODO revisar estas dos lineas a ver si hay que
				// borrar menos bits o que pasa. Ademas, pone "se
				// vuelven a borrar", pero en ningun sitio lo
				// habiamos borrado todavia!
  rI_ISPC = 0xFFFF; //BIT_EINT1; // FIXME esto esta como estaba. vale asi?

}

int KeyboardIntStateCheck(void) {

	if (get_current_state() == ESPERA_NUM_1 ||
		get_current_state() == ESPERA_NUM_2 ||
		get_current_state() == ESPERA_OP ||
		get_current_state() == ESPERA_CONFIRMACION) {
		return 1;
	}
	else {
		return -1;
	}
}

void KeyboardInt(void)
{
  /* Esperar trp mediante la funcion DelayMs()*/
  // Del manual: Para detectar correctamente una tecla es necesario esperar a que
  // terminen los rebotes de presion. Una forma es esperar durante un
  // tiempo superior al tiempo de rebote de presion minimo previsto
  // (trp) despues de haber detectado la pulsacion. Suponemos que para
  // este tipo de teclado trp son 20ms
  DelayMs(20);
  
  State prev_state = get_current_state();

  /* Identificar la tecla */
  key = key_read();
  /* Si la tecla se ha identificado, visualizarla en el 8SEG*/
  if(key > -1) {
	if (KeyboardIntStateCheck() == -1) {
		mostrar_error();
	}
	else { // en caso contrario lo mostramos
		if (prev_state == ESPERA_NUM_1 ||
			prev_state == ESPERA_NUM_2 ||
			prev_state == ESPERA_OP) {

			D8Led_symbol(key); // mostramos el numero en hexa en el display 8seg
			DelayMs(100); // eliminamos rebotes
		}
	}
  }

  /* Esperar a se libere la tecla: consultar bit 1 del registro de datos del puerto G */
    // Tambien se deben eliminar los rebotes de depresion. Como no
    // conocemos el momento en que el usuario va a dejar de pulsar la
    // tecla, la forma mas segura de evitar los rebotes de depresion
    // consiste en detectar la transacion de depresion, y solo
    // entonces esperar durante un tiempo superior al rebote de
    // depresion (tr). Esto permitira eludir los rebotes de depresion
    // antes de dar por finalizado el proceso de identificacion. Para
    // detectar la transicion de depresion se esperara a que la linea
    // EINT1 tome el valor '1' y despues esperamos trd=100ms. Para
    // leer el valor de EINT1 consultaremos el bit 1 de PDATG
  while (rPDATG & 0x2 != 0x2){ // esperamos hasta que el bit 1 sea 1
    //NOTHING
  }
  /* Esperar trd mediante la funcion Delay() */
  DelayMs(100);

  if (prev_state == ESPERA_NUM_1 && key >= 0 && key <= 9) {
	  // pasamos a estado esperar op
	  first_num = key;
	  set_current_state(ESPERA_OP);
  }
  else if (prev_state == ESPERA_NUM_2 && key >= 0 && key <= 9) {
	  // pasamos a estado esperar = 
	  second_num = key;
	  set_current_state(ESPERA_CONFIRMACION);
  }
  else if (prev_state == ESPERA_OP && (key == 16 || key == 17 || key == 18)) {
	  op = key;
	  set_current_state(ESPERA_NUM_2);
  }
  else if (prev_state == ESPERA_CONFIRMACION && key == 19) {
	  // hemos pulsado un =, asi que perfecto. El usuario quiere ver su resultado, asi que
	  // desde aqui lo hacemos
	  if (first_num >= 0 && first_num <= 9 && second_num >= 0 && second_num <= 9
			  && (op == 16 || op == 17 || op == 18)) {
		  calcular_y_mostrar(first_num, second_num, op); // TODO. Meter timers etc
	  }
	  else {
		  // no tenemos ni idea de lo que has hecho para llegar hasta aqui pero oye... que
		  // la has liado :/
		  mostrar_error();
	  }
  }
  else {
	  // pues nada, que has vuelto a pulsar una tecla que no debias... te tenemos que mostrar
	  // el error, lo siento :(
	  mostrar_error();
  }

  //
  /* Borrar interrupción de teclado */
  // FIXME mirar si esto esta bien
  // Comentario de Jen:
  // borramos los bits en EXTINTPND
  // borramos el bit pendiente en INTPND escribiendo en ISPC
  rEXTINTPND = rEXTINTPND | 0xC;
  rI_ISPC = BIT_EINT1;
}
int key_read() // por el momento suponemos que queremos mostrar los
			// numeros en hexa. Ya lo cambiaremos para el apartado
			// b
{
  int value= -1;
  char temp;
  // Identificar la tecla mediante ''scanning'' Si la identificación
  // falla la función debe devolver -1. Como esta puesto por defecto
  // el value=-1, no tenemos que hacer nada extra.
  temp = *(keyboard_base + 0xfd) & KEY_VALUE_MASK; // primera fila
  //Usamos KEY_VALUE_MASK para quedarnos con los 4 bits menos significativos

  switch (temp) {
  case 0x7:  value = 7; break; // primera fila, columna 1: SB1
  case 0xB:  value = 8; break; // primera fila, columna 2: SB5
  case 0xD:  value = 9; break; // primera fila, columna 3: SB9
  case 0xE:  value = 16; break; // primera fila, columna 4: SB13. A. Add
  }

  // Vamos ahora con la segunda fila...
  temp = *(keyboard_base + 0xfb) & KEY_VALUE_MASK; 
  switch (temp) {
  case 0x7:  value = 4; break; // segunda fila, columna 1: SB2
  case 0xB:  value = 5; break; // segunda fila, columna 2: SB6
  case 0xD:  value = 6; break; // segunda fila, columna 3: SB10
  case 0xE:  value = 17; break; // segunda fila, columna 4: SB14. -. Substract
  }
  
  // Vamos ahora con la tercera fila...
  temp = *(keyboard_base + 0xf7) & KEY_VALUE_MASK;
  switch (temp) {
  case 0x7:  value = 1; break; // tercera fila, columna 1: SB3
  case 0xB:  value = 2; break; // tercera fila, columna 2: SB7
  case 0xD:  value = 3; break; // tercera fila, columna 3: SB11
  case 0xE:  value = 18; break; // tercera fila, columna 4: SB15. *
  }
  
  // Vamos ahora con la cuarta fila...
  temp = *(keyboard_base + 0xef) & KEY_VALUE_MASK; 
  switch (temp) {
  case 0x7:  value = 15; break; // cuarta fila, columna 1: SB4. F. Sin usar
  case 0xB:  value = 0; break; // cuarta fila, columna 2: SB8
  case 0xD:  value = 15; break; // cuarta fila, columna 3: SB12. F. Sin usar
  case 0xE:  value = 19; break; // cuarta fila, columna 4: SB16. =
  }
    
  return value;

}
